# Java核心面试知识点整理

***

## Java基础

### Java平台的理解

- 跨平台：书写一次，到处运行
- GC：自动垃圾回收，不用操心内存的分配和回收
- jre：Java运行环境，包含jvm和Java类库和其他一些模块
- jdk：jre的超集，提供更多的工具，提供编译器、各种诊断工具

### Java是解释执行还是编译执行

&ensp;&ensp;&ensp;&ensp;代码首先编译成字节码，jvm在编译成机器码后执行。但动态编译器（JIT）会将热点代码编译成机器码，这种属于编译执行。则Java有解释执行，也有编译执行。

### 对比Exception和Error

&ensp;&ensp;&ensp;&ensp;在Java中对于错误和异常的处理是不同的，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。

- Exception和Error都继承自Throwable，能被抛出或者捕获，异常处理机制的基本组成类型
- Exception是正常运行是可以预料到的意外情况，需要进行捕获，然后可以进行处理；属于可检查异常
- Error是正常情况下不太可能出现的意外情况，大部分会导致程序处于非正常、不可恢复的状态，不便也不需要进行捕获；属于不检查异常

### 运行时异常与一般异常有什么区别

&ensp;&ensp;&ensp;&ensp;运行时异常就是不检查异常，如越界、空指针；通常是编码可以避免的错误，具体根据需求来进行捕获，并不会在编译器强行要求

### 谈谈 final、finally、 finalize 有什么不同

- final是一个修饰符，可以修饰变量、方法、类；修饰变量表示变量不可变；修饰方法表示方法在子类中不可被重写；修饰类表示不可被继承
  - 多线程中常量用final修饰，可以表示线程安全，省却额外的同步开销、防御性拷贝
  - 可能有助于jvm将方法内联
- finally是异常处理相关，和try等一起使用，常用语资源的释放，如数据连接，锁等
- finalize类似C++的析构函数，也就是类销毁前进行特定资源的回收，当现在已经不推荐使用了，因为GC是不可预期的
  - try-with-resource、ref.Clean

### 强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？

&ensp;&ensp;&ensp;&ensp;主要区别是其引用对象可达性对垃圾回收的影响

- 强引用：
  - 只要有强引用指向某个对象，则这个对象不会被回收
- 软引用：
  - 在内存不足的情况下，被软引用指向的对象可能会被回收
  - 用于缓存
- 弱引用：
  - 不能避免被回收
  - 有对象则引用，没有则新建，用于缓存
- 幻象引用（虚引用）：
  - 不能通过它访问对象，提供对象被销毁后做某些事情的机制
  - 用于清理，监控对象的创建和销毁

### 理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别

&ensp;&ensp;&ensp;&ensp;String是Java中基础重要常用的类，它是一个不可变类，方法属性都是否final修饰了的。由于它的不可变性，其裁剪、拼接等操作都是使用copy-on-write，直接生成新的对象返回。而大量的裁剪、拼接操作生成大量对象，对应用的性能产生明显的影响，所有后面stringBuffer和StringBuilder是为了解决这个问题而出现的。

&ensp;&ensp;&ensp;&ensp;stringBuffer和StringBuilder都是通过append或者add函数添加字符串到已有字符串末尾。而StringBuffer是线程安全的，StringBuilder不是线程安全的。没有线程安全的需要的话就使用StringBuilder，反之使用StringBuffer，由于线程安全需要加锁，所有性能稍差。

#### 扩展

- stringBuffer和StringBuilder初始大小默认是16，开始可自行指定大小，避免多次扩容带来的开销
- jvm非静态拼接能自动转StringBuilder
- String的演进：char存储--6：压缩字符串，但存在bug后移除--9：byte加编码coder（需要进行明确的编码？）

### 谈谈 Java 反射机制，动态代理是基于什么原理

- 反射是Java提供基础功能，赋予程序在运行时自省的能力。直接操作类和对象，获取类定义、方法、属性、调用方法、构造对象、运行时修改类定义
- 动态代理是方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，如包装RPC调用，面向切面编程
- 动态代码可以使用Java的反射实现，也可以字节码操作机制

#### 扩展

- 考察你对反射机制的了解和掌握程度。
- 动态代理解决了什么问题，在你业务系统中的应用场景是什么
- JDK 动态代理在设计和实现上与 cglib 等方式有什么不同，进而如何取舍？

### int 和 Integer 有什么区别？谈谈 Integer 的值缓存范围。

- int是基础类型，Integer是对象
- -128-127之间

#### 扩展

- 我在专栏第 1 讲中介绍的 Java 使用的不同阶段：编译阶段、运行时，自动装箱 / 自动拆箱是发生在什么阶段？
- 我在前面提到使用静态工厂方法 valueOf 会使用到缓存机制，那么自动装箱的时候，缓存机制起作用吗？
- 为什么我们需要原始数据类型，Java 的对象似乎也很高效，应用中具体会产生哪些差异？
- 阅读过 Integer 源码吗？分析下类或某些方法的设计要点

### 对比 Vector、ArrayList、LinkedList 有何区别

- 都是有序集合，能对数据进行增伤改查
- LinkList基于双向链表实现；Vector、ArrayList基于数组进行实现，能动态进行扩容，Vector扩大1倍，而ArrayList扩大0.5倍
- Vector是线程安全的，其他两个不是

### 对比 Hashtable、HashMap、TreeMap 有什么不同？谈谈你对 HashMap 的掌握。

- 都是以键值对存储的数据类型
- hashtable是哈希表的实现，是线程安全的，不支持null
- hashMap和hashtable，但不是线程安全的，支持null
- TreeMap是基于红黑树实现的，get、put、remove都是O(logN)，不是线程安全的，支持null

#### 扩展

- 理解 Map 相关类似整体结构，尤其是有序数据结构的一些要点。
- 从源码去分析 HashMap 的设计和实现要点，理解容量、负载因子等，为什么需要这些参数，如何影响 Map 的性能，实践中如何取舍等。
- 理解树化改造的相关原理和改进原因。

- 哈希值的有效性
  - equals 相等，hashCode 一定要相等。
  - 重写了 hashCode 也要重写 equals。
  - hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。
  - equals 的对称、反射、传递等特性。

### 如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全

- Java提供了同步包装器，使用函数进行包装即可，也就是方法加上synchronized修饰，缺点是粗粒度同步，性能低下，高并发下不能使用
- 并发包提供的线程安全容器类
  - 各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList。
  - 各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue。
  - 各种有序容器的线程安全版本等。

#### 扩展

- 理解基本的线程安全工具。
- 理解传统集合框架并发编程中 Map 存在的问题，清楚简单同步方式的不足。
- 梳理并发包内，尤其是 ConcurrentHashMap 采取了哪些方法来提高并发表现。
- 最好能够掌握 ConcurrentHashMap 自身的演进，目前的很多分析资料还是基于其早期版本。

### Java 提供了哪些 IO 方式？ NIO 如何实现多路复用

- 基于流模型实现，提供一些熟知的I/O功能，如文件、输入输出等；交互方式同步、阻塞方式；简单直观，容易成性能瓶颈
- 提供了Channel、Selector、Buffer等新的抽象，可以构建多路复用、同步非阻塞I/O
- NIO2基于事件和回调，实现异步非阻塞I/O

#### 扩展

- 基础 API 功能与设计， InputStream/OutputStream 和 Reader/Writer 的关系和区别。
- NIO、NIO 2 的基本组成。给定场景，分别用不同模型实现，分析 BIO、NIO 等模式的设计和实现原理。
- NIO 提供的高性能数据操作方式是基于什么原理，如何使用？
- 或者，从开发者的角度来看，你觉得 NIO 自身实现存在哪些问题？有什么改进的想法吗？

### Java 有几种文件拷贝方式？哪一种最高效

- io库：FileInputStream、FileOutputStream
- nio库：TransferTo、TransferFrom，利用了操作系统底层机制，避免不必要的拷贝和上下文切换，可能较快

#### 扩展

- 不同的 copy 方式，底层机制有什么区别？
- 为什么零拷贝（zero-copy）可能有性能优势？
- Buffer 分类与使用。
- Direct Buffer 对垃圾收集等方面的影响与实践选择。

### 谈谈接口和抽象类有什么区别

- interface：对行为的抽象，抽象方法的集合，利用他可以达到API定义和实现分离的目的；不能实例化；只能包含常量成员和静态方法/抽象方法
- abstract:抽取类的公共部分，利用继承达到代码复用的目的；不能实例化；成员和方法和一般类一样，没有其他限制

### 扩展

- 对于 Java 的基本元素的语法是否理解准确。能否定义出语法基本正确的接口、抽象类或者相关继承实现，涉及重载（Overload）、重写（Override）更是有各种不同的题目。
- 在软件设计开发中妥善地使用接口和抽象类。你至少知道典型应用场景，掌握基础类库重要接口的使用；掌握设计方法，能够在 review 代码的时候看出明显的不利于未来维护的设计。
- 掌握 Java 语言特性演进。现在非常多的框架已经是基于 Java 8，并逐渐支持更新版本，掌握相关语法，理解设计目的是很有必要的。

- 多继承的实现，不用在接口中添加，可以使用实现静态工具类
