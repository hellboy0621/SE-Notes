# Spring Cloud Gateway （七）处理流程
***
## 简介
&ensp;&ensp;&ensp;&ensp;初步梳理 Spring Cloud Gateway 的处理流程

### 过程记录
#### 主要请求流程
&ensp;&ensp;&ensp;&ensp;在前面的分析中，我们知道在 RoutePredicateHandlerMapping 中是实现了路由查找，于是在这个类中 getHandlerInternal 函数打上断点，通过调用栈向前追溯调用

&ensp;&ensp;&ensp;&ensp;向前我们追溯到了 DispatcherHandler ,在这个断点处通过断点调试发现有类似循环的操作，这个感觉是查找相应 handler 进行处理，细节部分暂时不够，后面再来详细看

```java
    public Mono<Void> handle(ServerWebExchange exchange) {
        return this.handlerMappings == null ? this.createNotFoundError() : Flux.fromIterable(this.handlerMappings).concatMap((mapping) -> {
            return mapping.getHandler(exchange);
        }).next().switchIfEmpty(this.createNotFoundError()).flatMap((handler) -> {
            return this.invokeHandler(exchange, handler);
        }).flatMap((result) -> {
            return this.handleResult(exchange, result);
        });
    }
```

&ensp;&ensp;&ensp;&ensp;在上面函数打断点，再通过调用栈向前查找，找到 netty 相关的一个类： HttpServerHandle 。下面的函数中有类似 Mono 这里的代码，感觉就是发布东西到后面的 DispatcherHandler ,但具体传递路径目前还没有搞清楚

```java
    public void onStateChange(Connection connection, State newState) {
        if (newState == HttpServerState.REQUEST_RECEIVED) {
            try {
                if (log.isDebugEnabled()) {
                    log.debug(ReactorNetty.format(connection.channel(), "Handler is being applied: {}"), new Object[]{this.handler});
                }

                HttpServerOperations ops = (HttpServerOperations)connection;
                // Mono 发布
                Mono.fromDirect((Publisher)this.handler.apply(ops, ops)).subscribe(ops.disposeSubscriber());
            } catch (Throwable var4) {
                log.error(ReactorNetty.format(connection.channel(), ""), var4);
                connection.channel().close();
            }
        }
    }
```

&ensp;&ensp;&ensp;&ensp;结合前面的分析，那处理流程设计的类基本如下：

- HttpServerHandle : netty 的服务端，接收客户端请求
- DispatcherHandler : 请求调度器，负责请求分发
- FilteringWebHandler : 使用 filter 链表处理请求的 WebHandler
- Filter : 一系列的操作， WebsocketRoutingFilter/NettyRoutingFilter 负责请求到后台服务器并接受请求， NettyWriteResponseFilter 返回响应到客户端


#### 定制化filter的来源
&ensp;&ensp;&ensp;&ensp;非 global filter 从 routeLocator 中获取的，跟踪 routeLocator 看其的来源

```java
    protected Mono<Route> lookupRoute(ServerWebExchange exchange) {
        // routeLocator 跟踪堆栈发现是 CachingRouteLocator
		return this.routeLocator.getRoutes()
				// individually filter routes so that filterWhen error delaying is not a
				// problem
				.concatMap(route -> Mono.just(route).filterWhen(r -> {
					// add the current route we are testing
					exchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());
					return r.getPredicate().apply(exchange);
				})
						// instead of immediately stopping main flux due to error, log and
						// swallow it
						.doOnError(e -> logger.error(
								"Error applying predicate for route: " + route.getId(),
								e))
						.onErrorResume(e -> Mono.empty()))
				// .defaultIfEmpty() put a static Route not found
				// or .switchIfEmpty()
				// .switchIfEmpty(Mono.<Route>empty().log("noroute"))
				.next()
				// TODO: error handling
				.map(route -> {
					if (logger.isDebugEnabled()) {
						logger.debug("Route matched: " + route.getId());
					}
					validateRoute(route, exchange);
					return route;
				});

		/*
		 * TODO: trace logging if (logger.isTraceEnabled()) {
		 * logger.trace("RouteDefinition did not match: " + routeDefinition.getId()); }
		 */
	}
```

&ensp;&ensp;&ensp;&ensp;再跟踪 CachingRouteLocator ，发现是从 CompositeRouteLocator 来的

```java
    public CachingRouteLocator(RouteLocator delegate) {
		this.delegate = delegate;

        // 这里提供一种Flux流缓存构造方式，他的意思是，当cache没有的时候，
        // 我们执行this.delegate.getRoutes().sort(AnnotationAwareOrderComparator.INSTANCE)获得Flux流，并把这个结果写入cache这个Map。
        // 这不会马上执行，当有subscribe才会执行。是懒加载方式。
		routes = CacheFlux.lookup(cache, CACHE_KEY, Route.class)
				.onCacheMissResume(this::fetch);
	}

    private Flux<Route> fetch() {
        // 这个方法是一个核心的方法。负责把所有routeDefinition转换为route。是连接RouteDefinitionLocator和RouteLocator的通道
		return this.delegate.getRoutes().sort(AnnotationAwareOrderComparator.INSTANCE);
	}


    @Bean
	@Primary
	@ConditionalOnMissingBean(name = "cachedCompositeRouteLocator")
	// TODO: property to disable composite?
	public RouteLocator cachedCompositeRouteLocator(List<RouteLocator> routeLocators) {
        // routeLocators 里面有大量的 定制化的 filter factory
		return new CachingRouteLocator(new CompositeRouteLocator(Flux.fromIterable(routeLocators)));
	}

    public Flux<Route> getRoutes() {
		return this.delegates.flatMapSequential(RouteLocator::getRoutes);
	}
```

&ensp;&ensp;&ensp;&ensp;跟踪 CompositeRouteLocator 发现是初始化加载就初始化好了，大致流程是知道，细节后面再看，因为这部分属于加载了，后面分析这部分的时候再分析